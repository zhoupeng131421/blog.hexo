---
title: shell grammar chips
date: 2020-12-03
tags: [shell, readlink]
categories: Learning
---

# readlink
> Linux中的readlink命令用于打印解析的符号链接或规范文件名。用简单的话来说，只要我们有一个符号链接，我们就想知道它代表什么路径。然后，在这种情况下，将使用readlink命令显示符号链接的实际路径。

- `readlink [选项] ...文件...`
- `readlink -f`：通过递归跟随给定名称的每个组件中的每个符号链接，此选项可以规范化；除最后一个组件外，所有组件都必须存在
- `readlink -e`：通过递归跟随给定名称的每个组件中的每个符号链接，此选项将规范化，所有组件必须存在。
- `readlink -m`：此选项可以通过对给定名称的每个组件中的每个符号链接进行递归跟踪来规范化，而无需组件存在。
- `readlink -n`：此选项将不输出结尾定界符。
- `readlink -q`：此选项将在安静模式下执行。
- `readlink -s`：此选项将禁止显示大多数错误消息。
- `readlink -v`：此选项将报告错误消息（如果有）
- `readlink -z`：此选项将以NUL（而不是换行符）结尾每条输出行。

# dirname
> dirname命令可以取给定路径的目录部分。这个命令很少直接在shell命令行中使用，我一般把它用在shell脚本中，用于取得脚本文件所在目录，然后将当前目录切换过去。basename，它与dirname相反，是取得文件名称部分。

- [xxx ~]#: `dirname filename`

- script:

    ```shell
    #!/bin/sh  
    
    # jump to the folder of the script
    cd $(dirname "$0") || exit 1
    ```

# basename
- basename 命令读取 String 参数，删除以 /(斜杠) 结尾的前缀以及任何指定的 Suffix 参数，并将剩余的基本文件名称写至标准输出。简而言之，就是输出文件名。

# set
> set 指令可根据不同的需求来设置当前所使用 shell 的执行方式，同时也可以用来设置或显示 shell 变量的值

- `set [-可选参数] [-o 选项]`

|paramter|desc|
| - | - |
| -a |标示已修改的变量，以供输出至环境变量|
|-b|使被中止的后台程序立刻回报执行状态|
|-d|Shell预设会用杂凑表记忆使用过的指令，以加速指令的执行。使用-d参数可取消|
|`-e`|若指令传回值不等于0，则立即退出shell|
|-f|取消使用通配符|
|-h|自动记录函数的所在位置|
|-k|指令所给的参数都会被视为此指令的环境变量|
|-l|记录for循环的变量名称|
|-m|使用监视模式|
|-n|测试模式，只读取指令，而不实际执行|
|-p|启动优先顺序模式|
|-P|启动-P参数后，执行指令时，会以实际的文件或目录来取代符号连接|
|-t|执行完随后的指令，即退出shell|
|-u|当执行时使用到未定义过的变量，则显示错误信息|
|-v|显示shell所读取的输入值|
|-H shell|可利用”!”加<指令编号>的方式来执行 history 中记录的指令|
|`-x`|执行指令后，会先显示该指令及所下的参数|
|+<参数>|取消某个set曾启动的参数。与-<参数>相反|
|-o option|特殊属性有很多，大部分与上面的可选参数功能相同，这里就不列了|
- *`set -x`* 会在执行每一行 shell 脚本时，把执行的内容输出来。它可以让你看到当前执行的情况，里面涉及的变量也会被替换成实际的值。

- *`set -e`* 会在执行出错时结束程序，就像其他语言中的“抛出异常”一样。（准确说，不是所有出错的时候都会结束程序）
    - 一个 pipeline 的非结尾部分，比如error | ok
    - 一个组合语句的非结尾部分，比如ok && error || other
    - 一连串语句的非结尾部分，比如error; ok
    - 位于判断语句内，包括test、if、while等等。